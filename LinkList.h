#pragma once
typedef struct LNode
{
	int data;
	struct LNode* next;
}*Link, * Position;

typedef struct
{
	Link head, tail;
	int len;
}LinkList;

int makeNode1(Link&, int);
void freeNode1(Link&);

int initList1(LinkList&);
int destroyList1(LinkList&);
int clearList1(LinkList&);
int insFirst1(Link, Link); // 已知h指向线性表的头节点，将s所指节点插入在第一个结点之前
int delFirst1(Link, Link&); // 已知h指向线性表的头节点，删除链表中的第一个节点并以q返回
int append1(LinkList&, Link);//将指针s所指（彼此以指针相连）的一串节点链接在线性链表L的最后一个节点，
							//之后改变链表L的尾指针指向新的尾节点
int remove1(LinkList&, Link&);//删除尾节点
int insBefore1(LinkList&, Link&, Link);//已知p指向线性链表L中的一个节点，将s所指节点插入在p所指节点之前，并修改p指向新插入的节点
int insAfter1(LinkList&, Link&, Link);//已知p指向线性链表L中的一个节点，将s所指节点插入在p所指节点之后，并修改p指向新插入的节点
int setCurElem1(Link&, int); //用e更新p所指结点中数据元素的值
int getCurElem1(Link); //返回p所指向节点中元素的值
int listEmpty1(LinkList);
int listLength1(LinkList);
Position getHead1(LinkList); //返回L头节点的位置
Position getLast1(LinkList); //返回L尾节点的位置
Position priorPos1(LinkList, Link);//p前驱的位置，若无返回null
Position nextPos1(LinkList, Link);//p后缀
int locatePos1(LinkList, int, Link&); //返回第i个节点的位置并返回ok，i值不合法返回ok
int listTraverse1(LinkList, int (*visit)(int));